---
layout: page
title:  "Общее представление"
date: 2016-09-26 14:13:19 UTC
categories: ru
---

Lisp, кто бы что не говорил, не тарабарщина, Lisp - это божественный, безумно [древний](https://ru.wikipedia.org/wiki/IBM_704) язык! И невероятно простой. Научить лиспу можно даже дошкольника, лишь бы он умел читать и писать (неоднократно проверено). Но вместе с этим из очень простых конструкций этого языка можно легко и быстро построить сложные, непостижимо умные программы.

В этом разделе приводятся базовые сведения о минимально нужном наборе конструкций языка. С помощью этих знаний можно будет легко понимать приводимые примеры и перейти к более сложным вещам.

В контексте изложения можно встретить разные наименования языка, в приложении к которому идет речь. Важно понимать различие:

* [Lisp](https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF) - базовый язык собственной персоной. Общие концепции языка, философия и синтаксис присущи для всего семейства потомков (диалектов) языка.
* [Scheme](https://ru.wikipedia.org/wiki/Scheme) - один из самых распространенных диалектов языка Lisp (другим не менее распространенным является Common Lisp, вообще же - сотни их). Все, что помечено как Scheme, является специфическим именно для философии Scheme.
* [R<sup>7</sup>RS](http://www.r7rs.org) - один из используемых стандартов Scheme (их несколько, R<sup>3</sup>RS, R<sup>4</sup>RS, ..., R<sup>7</sup>RS), на котором базируется базовая библиотека Ol. Этот стандарт расширяется целым набором набором [SRFI](http://srfi.schemers.org/).
* И, собственно, сам [Otus Lisp](http://yuriy-chumak.github.io/ol/). Все помеченное этим именем, либо его часто используемым сокращением "Ol", специфично только и именно для описываемой реализации языка.

Следует указать, что все помеченное как Lisp полностью включается в Scheme, а как Scheme - в R<sup>7</sup>RS. Но не все из R<sup>7</sup>RS включается в Ol, так как Ol - чисто функциональный диалект, а R<sup>7</sup>RS - мультипарадигменный стандарт (подразумевает также и императивные элементы поведения языка). Такие различия будут в обязательном порядке оговорены.

### Основы

Переходим к списку основных конструкций языка:

#### Комментарии

Наименее существенная, но первая из описываемых конструкций языка - комментарий. Комментарий, это полностью игнорируемая часть текста программы, предназначенная для человека, не для компилятора.

Комментарии в лисп бывают однострочные и многострочные. Однострочные обозначаются точкой с запятой (;) и длятся до конца строки.

Многострочные начинаются с диграфа #| и заканчиваются диграфом |#. Все, что находится между ними, полностью игнорируется лиспом.

#### Списки

Наиболее же существенная, а так же важнейшая для понимания философии языка, конструкция Lisp - списки. По большому счету, Lisp - это и есть списки, много списков, очень много списков списков.

Списки являются необходимейшей конструкцией Lisp - его название расшифровывается как "обработчик списков" (LISt Processor). И сама программа, которую дают выполнить Lisp'у - тоже список.

Конструируются списки с помощью круглых скобок - открывающей список левой скобки "(" и закрывающей список правой ")". А так как списков в программе много, то и скобок тоже много. Их количество у некоторых может вызывать даже некое возмущение, что давным-давно вылилось в старую добрую шутку об альтернативной расшифровке акромина Lisp как "Lots of Irritating Stupid Parentheses" (много раздражающих глупых скобок). Но к скобкам очень быстро привыкается, они легко занимают свое место в голове и при правильном форматировании исходного текста программы не только не мешают, но существенно облегчают чтение программы. Что, впрочем, относится к любому языку программирования.

Между скобками размещаются элементы списка, разделенные пробельными сомволами (как минимум - одним, как максимум - на ваше усмотрение), слева направо. Никаких ограничений на типы элементов не накладывается - это могут быть числа, строки, другие списки. Вкладывая списки в списки, мы формируем целое дерево элементов (если нарисовать списки соответственно уровню их вложенности и местом, где они должны были быть размещены - получится эдакое стилизованное дерево). Это дерево в Lisp называется AST (АСД) - Abstract Syntax Tree (абстрактное синтаксическое дерево).

Если список отдать на выполнение Lisp'у, он будет его понимать строго опеределенным образом - первый элемент списка Lisp всегда будет считать операцией - командой, которую надо выполнить над оставшейся частью списка. Эта логика будет применена Lisp'ом к каждому элементу, если он в свою очередь является тоже списком; и так далее рекурсивно (разбор понятия *рекурсии* тоже оставим надлежащему времени и месту), пока больше не останется не обработанных списков. Этот процесс и называется процессом *вычисления* Lisp-программы (в терминах Lisp - EVAL).

Вот несколько примеров списков, которые можно сразу опробовать *вычислить* в терминале:

<pre><code id="list1" data-language="scheme">(* 1 2 3 4 5 6 7 8 9)</code><button class="doit" onclick="doit(list1.textContent)">отправить в терминал</button></pre>

<pre><code id="list2" data-language="scheme">(print "Hello John!")</code><button class="doit" onclick="doit(list2.textContent)">отправить в терминал</button></pre>

<pre><code id="list3" data-language="scheme">(print "Ну или привет, если так понятнее.")</code><button class="doit" onclick="doit(list3.textContent)">отправить в терминал</button></pre>

<pre><code id="list4" data-language="scheme">(print "2+2 = " (+ 2 2))</code><button class="doit" onclick="doit(list4.textContent)">отправить в терминал</button></pre>

Существует довольно небольшой список (да, снова список, и это не каламбур) базовых команд, и довольно большой список построенных из них команд посложнее, которые собраны в стандарты (для Scheme - это, например, уже упомянутый во вступлении R<sup>7</sup>RS, есть и другие; Otus Lisp реализует большую часть этого стандарта и может выполнять многие программы написанные для других диалектов Lisp, следующих указанному стандарту). Стандарт будет рассмотрен в соответствующем месте, пока же стоит упомянуть только, что **print** выводит элементы списка на стандартное устройство вывода (например, в консоль), **car** возвращает первый элемент списка, **cdr** возвращает оставшуюся без первого элемента часть списка, а **\***, **+**, **-**, **/** - математические операции над элементами списка.

Странность названий car и cdr сложилась [исторически](https://en.wikipedia.org/wiki/CAR_and_CDR), их надо просто запомнить.

Пустой список создается через (list ) и имеет, ввиду своего широкого использования, сразу несколько обозначений: #null, null и '(). Какое из них использовать - дело вкуса и интуиции.

Что еще можно делать со списками мы рассмотрим позже.

#### Кортежи

Otus Lisp поддерживает специализированную форму списка заранее заданной длины - кортеж. В отличие от обычных списков некоторые операции с кортежами существенно быстрее. Например, время доступа к любому элементу кортежа одинаково, в то время как у списка доступ к первому элементу самый быстрый, а к последнему самый медленный. Также, есть несколько специальных конструкций языка, ведущих к более интуитивно понятному написанию программ - речь идет о конструкции tuple-case.

Кортежи конструируются с помощью инструкции (tuple ).

Более детально о кортежах будет рассказано в специально отведенном для кортежей разделе.

#### #true и #false

В качестве первого простого значения, представленного в Lisp, мы выберем пару булевых констант **#true** и **#false**. В Scheme они, как пустой список и по той же причине, имеют дополнительное альтернативное обозначение **#t** и **#f**.

Эти константы используются в условном операторе и в качестве результата предикатов.

Надо отметить, что условный оператор if работает с любыми аргументами, не только с #true и #false. При этом в качестве правды оператор if трактует все, что не является #false - таким образом #false является сильным предикатом, в отличие от своей пары #true.

Обратите внимание на такой момент, так как он довольно часто вызывает недопонимание - специальное значение #null (пустой список) не является #false. Таким образом (if #null 1 2) вернет один, а не два. Это важно, так как такое поведение характерно не для всех диалектов лиспа.

#### Числа

Следующей базовой вещью в Lisp являются числа. В отличие от большинства языков программирования, точные числа в Lisp не ограничены величиной машинного слова, а только количеством доступной программе оперативной памяти. Таким образом, в Lisp можно спокойно использовать точные числа, состоящие из сотен и тысяч знаков.

Числа подразделяются на несколько классов:

1. Класс integer чисел - это целые (Z) числа, представленные в обычном математическом виде последоватльностью цифр. Как уже было указано, их размер не ограничен размером машинного слова целевой платформы и легко может превышать его. Целые числа можно вводить в виде десятичного, шестнадцатиричного, восьмиричного и двоичного числа - используя префикс #d, #x, #o и #b соответственно.
<pre><code id="Z1" data-language="scheme">123456789876543212345678987654321</code><button class="doit" onclick="doit(Z1.textContent)">отправить в терминал</button></pre>
<pre><code id="Z2" data-language="scheme">(* 12345678987654321 98765432123456789)</code><button class="doit" onclick="doit(Z2.textContent)">отправить в терминал</button></pre>

2. Класс rational чисел - это рациональные (Q) числа, которые представлены в виде дроби. В числителе дробь всегда содержит целое число, в знаменателе - натуральное (целое, большее нуля). Дробь рационального числа всегда является несократимой - если попытаться ввести сократимую дробь, то интерпретатор Lisp автоматически ее сократит; если возможно, то даже до целого числа. В Ol числитель рационального числа можно извлечь с помощью конструкции car, знаменатель - cdr.
<pre><code id="Q1" data-language="scheme">(print "todo: добавить пример")</code><button class="doit" onclick="doit(Q1.textContent)">отправить в терминал</button></pre>

3. Класс complex чисел - это комплексные (C) числа, которые представлены в виде A+Bi, где A и B - целые или натуральные числа, i - мнимая единица. Пробелы между частями комплексного числа не допускаются, (иначе они будут проинтерпретированы как самостоятельные, раздельные элементы списка). В Ol действительную часть числа можно извлечь с помощью конструкции car, мнимую - cdr. В свою очередь, если это натуральные числа, к ним можно снова применить car и cdr.
<pre><code id="C1" data-language="scheme">(* 0+3i 3-2i)  ; ==> 6+9i</code><button class="doit" onclick="doit(C1.textContent)">отправить в терминал</button></pre>

4. Иррациональные числа (I) в Ol "из коробки" не поддерживаются. Однако работу с ними можно организовать с помощью механизма расширений, о котором разговор будет в соответствующем разделе.

Для работы с числами предназначена математическая библиотека (owl math), предоставляющая большой набор математических функций, таких как +, -, *, /, modulo, gcd, min, max, quotient, floor, ceil и другие.

Более детально о внутреннем представлении чисел в Ol можно почитать в разделе о [внутреннем устройстве](?ru/internals/numbers) виртуальной машины Ol.


#### Строки

Наряду с числами Lisp умеет оперирировать непосредственным текстом - строками. Строки в Ol заключаются в двойные кавычки (") и полностью поддерживают юникод.

Для работы со строками используется набор специализированных функций, таких как string-length, string-eq?, string-append, substring и других. Необходимость наличия специализированных функций обусловлена тем, что с целью обеспечения быстрой и эффективной работы внутреннее представление строк является достаточно сложным (например, в Ol при добавлении к очень длинной строке короткой, длинная не будет дублироваться, теряя ресурсы на эту операцию).

С полным набором функций работы со строками можно ознакомиться в библиотеках (owl string) и (owl unicode), а также в (r5rs core).

TBD.

#### Символы

Лисперы очень любят символы. Это специфическое именно для лисп понятие, являющееся отдаленным аналогом переменных в других языках программирования. Однако в Lisp у символом более сложное и интересное поведение.

Начнем с того, что символы являются полностью самостоятельными элементами языка. Их можно передавать, принимать и вычислять. Причем получение значения символа происходит не во время компиляции, а во время выполнения.

Символы записываются обычной последовательностью не пробельных и не специальных знаков - букв, цифр, знаков +,-,*,?,!. Символы не могут начинаться с цифры.

Начальное значние символу присваивается с помощью директивы (define ) - в терминах лисп говорят "с символом связывается значение". После чего символ можно спокойно использовать в прогрмме.

   TBD.

#### Специальные формы

Специальными формами в Lisp называются такие конструкции языка, которые не могут быть выражены способами самого языка. Например, квотирующая форма quote.

В качестве базовых синтаксических конструкций Otus Lisp поддерживает минимально нужный набор специальных форм. Те из них, которые совпадают со специальными формами Lisp имеют соответствующее общее название. Те же, которые являются специфическими для Otus Lisp, имеют специальный префикс. Вот список этих форм.

* quote - квотирующая форма для символа, препятствует его интерпретации. Для упрощения ввода и чтения программы часто заменяется символом одинарной кавычки ('). Таким образом 'me является эквивалентом (quote me).
* lambda - объявление лямбда-функции, имеет несколько возможных вариантов объявления:
  * (lambda () <body>) - лямбда без аргументов
  * (lambda (a) <body>) - лямбда с одним аргументом
  * (lambda (a b) <body>) - лямбда с двумя аргументами
  * (lambda (a b <c d ...> <body>) - лямбда с тремя, четырьмя и т.д. аргументами)
  * (lambda args <body>) - лямбда с любым количеством аргументов, аргументы помещаются в args списком.
  * (lambda (a . x) <body>) - лямбда с одним и более аргументами, первый аргумент помещается в a, все остальные списком в x.
  * (lambda (a b . x) <body>) - лямбда с двумя и более аргументами, первый аргумент помещается в a, второй в b, все остальные списком в x.
  * (lambda (a b <c d ...> . x) <body>) - лямбда с тремя, четырьмя и т.д. и более аргументами, первый аргумент помещается в a, второй в b, третий в c, и т.д., все остальные списком в x.
* values - возвращает несколько значений одновременно
  * (let* ((a b c (values 1 2 3))) (print c b a)) => 321
* values-apply - передает несколько значений одновременно (созданных через values) в соответствующую лямбду, количество значений должно совпасть с количеством аргументов лямбды
  * (values-apply (values 1 2 3) (lambda (a b c) (print c b a))) => 321

* setq - связывание символа в текущем окружении со значением, прототип формы define
  * (setq x 12) - связывает символ x со значением 12, (print x) => 12
* bind - связывает список переменных со списком значений на время выполнения тела формы
  * (bind (a b c) (1 2 3) (print c b a)) => 321
* ifeq - "IF with Condition" - оператор ветвления в смысле eq?, имеет четыре аргумента (<параметр-1> <параметр-2> <если> <иначе>)
  * (let ((a 3) (b 4)) (ifeq a b (print "a и b равны") (print "a и b НЕ равны")))
* ifary - "IF with Arity" - оператор ветвления, имеет два аргумента, выполняет первый, если совпадает арность, иначе выполняет второй

С помощью формы ifary эффективно реализуется, например, форма case-lambda из srfi-16.

На первый взгляд, формы values-apply и bind взаимозаменяемы, однако это не так. Форма bind сначала размещает переменные в окружении, потом вычисляет значения и уже после этого связывает переменные со значениями. Что позволяет объявлять взаиморекурсивные конструкции. Форма values-apply наоборот, сначала вычисляет значения и уже потом с помощью объявления лямбды размещает переменные в окружении и связывает их со значениями.

   TBD.

#### Порты

   TBD.

#### Функции

   TBD. (а также внешние функции, результат (dload))

#### Макросы

   TBD.

   Some works more.

#### Словари (ассоциативные массивы)

Otus Lisp "из коробки" поддерживает словари - специализированный тип даных с довольно быстрыми операциями поиска и вставки значения по ключу. В качестве ключа могут быть использованы атомарные числа и символы.

   TBD.
